<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UltraCold: example-1</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/SVG"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">UltraCold
   </div>
   <div id="projectbrief">Collection of C++ libraries for the study of ultra-cold systems in the context of Gross-Pitaevskii theory</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('example-1.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">example-1 </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Title-1">A three-dimensional Bose gas in a harmonic trap.</a><ul><li class="level2"><a href="#Introduction-1">Introduction</a></li>
<li class="level2"><a href="#What-1">Program description</a></li>
<li class="level2"><a href="#Results-1">Results</a></li>
<li class="level2"><a href="#Possibilities-1">Possible extensions</a></li>
<li class="level2"><a href="#Uncommented-1">The plain program</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Santo Maria Roccuzzo (<a href="#" onclick="location.href='mai'+'lto:'+'san'+'to'+'m.r'+'oc'+'cuz'+'zo'+'@gm'+'ai'+'l.c'+'om'; return false;">santo<span class="obfuscator">.nosp@m.</span>m.ro<span class="obfuscator">.nosp@m.</span>ccuzz<span class="obfuscator">.nosp@m.</span>o@gm<span class="obfuscator">.nosp@m.</span>ail.c<span class="obfuscator">.nosp@m.</span>om</a>)</dd></dl>
<h1><a class="anchor" id="Title-1"></a>
A three-dimensional Bose gas in a harmonic trap.</h1>
<h2><a class="anchor" id="Introduction-1"></a>
Introduction</h2>
<p >In the first example, we are going to use UltraCold to study the ground state and a simple dynamics of a three-dimensional, harmonically trapped Bose gas of Rubidium atoms, using the solver class <code><a class="el" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html" title="Class to solve the Gross-Pitaevskii equation.">UltraCold::GPSolvers::GPSolver</a></code>, or, better, <b>extending</b> this class for customizing the runtime behavior of real-time simulations. All the solver classes delivered with UltraCold can, in fact, be partially extended according to possible different needs, in particular for customizing the output of dynamic simulations or adding time-dependent terms to the Hamiltonian of the system to simulate, e.g., a ramp in the scattering length.</p>
<p >We will, in particular, solve the Gross-Pitaevskii equation on a three-dimensional, homogeneous mesh, calculating first the ground state of the system in the presence of an isotropic harmonic trap, using the member function <code>run_gradient_descent</code>, and then running a real-time dynamic simulation of an experiment for the measurement of the frequency of the so-called <em>breathing mode</em>, using the member function <code>run_operator_splitting</code>. The frequency of this collective oscillation can be calculated analytically in the Thomas-Fermi approximation, and is equal to <a href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.77.2360">\( \omega_{breathing}=\sqrt{5}\omega_{ho}\)</a>. The breathing oscillation can be excited, for example, via a sudden isotropic shrinking of the harmonic trap. For the sake of illustration, however, we will use another procedure, namely a linear ramp in the scattering length, with a fixed time duration. This procedure, being isotropic in space, will still excite only the breathing mode we are interested in. It will also give us the opportunity to show how to derive a class from the base class <code> GPSolver </code> in order to introduce a time-dependent term in the Hamiltonian.</p>
<p >So, let's start from the Gross-Pitaevskii equation in three space dimensions, in the presence of an external harmonic potential</p>
<p class="formulaDsp">
\[
    i\hbar\frac{\partial \psi(x,y,z,t)}{\partial t} =
    \left[
        \frac{-\hbar^2\nabla^2}{2m}+\frac{1}{2}m(\omega^2_x x^2+\omega^2_y y^2 +\omega_z^2 z^2)
        + \frac{4\pi a\hbar^2}{m}|\psi(x,y,z,t)|^2
    \right]\psi(x,y,z,t)
\]
</p>
<p >Measuring frequencies in units of the average harmonic frequency \( \omega_{ho} = (\omega_x\omega_y\omega_z)^{\frac{1}{3}} \), lengths in units of the harmonic oscillator length \( a_{ho} = \sqrt{\frac{\hbar}{m\omega_{ho}}} \), and times in units of \( \omega_{ho}^{-1} \), the equation can be recast in a-dimensional form as</p>
<p class="formulaDsp">
\[
    i\frac{\partial \psi(x,y,z,t)}{\partial t} =
    \left[
        \frac{-\nabla^2}{2}+\frac{1}{2}(\omega_x^2 x^2+\omega^2_y y^2+\omega_z^2 z^2)
        + 4\pi a  |\psi(x,y,z,t)|^2
    \right]\psi(x,y,z,t)
\]
</p>
<p >We will now see how to solve this equation for our needs using tools provided by UltraCold.</p>
<h2><a class="anchor" id="What-1"></a>
Program description</h2>
<p >We first create an input file containing our mesh and physical parameters, as well as other parameters determining the run-time behavior of the system. Such input file will be called <code>example-1.prm</code> and contains the following text</p>
<pre class="fragment"># Mesh parameters

xmax = 10.0 # Size of the mesh along the x-axis, in micrometers. The mesh will extend from -xmax to xmax
ymax = 10.0 # Size of the mesh along the y-axis, in micrometers. The mesh will extend from -ymax to ymax
zmax = 10.0 # Size of the mesh along the z-axis, in micrometers. The mesh will extend from -zmax to zmax

nx = 64 # Number of points along the x-axis
ny = 64 # Number of points along the y-axis
nz = 64 # Number of points along the z-axis

# Physical parameters

initial scattering length   = 100.9  # Initial scattering length in units of the Bohr radius
number of particles         = 40000  # Total number of atoms
atomic mass                 = 87     # Atomic mass, in atomic mass units
omegax                      = 100 # Harmonic frequency along the x-axis, in units of (2pi)Hz
omegay                      = 100 # Harmonic frequency along the y-axis, in units of (2pi)Hz
omegaz                      = 100 # Harmonic frequency along the z-axis, in units of (2pi)Hz

# Run parameters for gradient descent

number of gradient descent steps = 10000 # maximum number of gradient descent steps
residual                         = 1.E-8 # Threshold on the norm of the residual
alpha                            = 1.E-4 # gradient descent step
beta                             = 0.9   # step for the heavy-ball acceleration method

# Run parameters for real-time dynamics

number of real time steps = 50000 # Total number of time-steps for real time dynamics
time step                 = 0.001 # Time step for real-time dynamics, in milliseconds
final scattering length   = 90.0  # Final scattering length in units of the Bohr radius
ramp duration             = 20.0  # Duration of the ramp of the scattering length, in milliseconds</pre><p >We will see shortly how to read this file inside our <code>main()</code> function, using the class <code><a class="el" href="class_ultra_cold_1_1_tools_1_1_input_parser.html" title="Class to read input parameters from files.">UltraCold::Tools::InputParser</a></code>.</p>
<p >Let's take a look at the source code contained in the file <code>/examples/example-1/example-1.cpp</code>.</p>
<p >The first line includes the header file <code>"UltraCold.hpp"</code>, which allows to import all the interfaces to classes and functions available in the library.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;UltraCold.hpp&quot;</span></div>
</div><!-- fragment --><p >The second line imports the namespace <code><a class="el" href="namespace_ultra_cold.html" title="All the classes and functions necessary to work with UltraCold.">UltraCold</a></code>, which wraps all the namespaces available in the library.</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespace_ultra_cold.html">UltraCold</a>;</div>
<div class="ttc" id="anamespace_ultra_cold_html"><div class="ttname"><a href="namespace_ultra_cold.html">UltraCold</a></div><div class="ttdoc">All the classes and functions necessary to work with UltraCold.</div><div class="ttdef"><b>Definition:</b> BogolyubovSolver.cpp:25</div></div>
</div><!-- fragment --><p >As said, we will solve the Gross-Pitaevskii equation using a class derived from the <code><a class="el" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html" title="Class to solve the Gross-Pitaevskii equation.">UltraCold::GPSolvers::GPSolver</a></code> class, which uses, under the hood, functions from Intel's Math Kernel Library to perform some mathematical operations, in particular dynamic allocation of data arrays and Fast Fourier Transforms. In the derived solver class, it is possible, among other things, to override the member functions <code>run_operator_splitting(...)</code>, which solves the Gross-Pitaevskii equation using operator splitting, <code>solve_step_1_operator_splitting(...)</code>, which solves the first step in the operator splitting method and allows to add time-dependent terms in the Hamiltonian, and <code>write_operator_splitting_output(...)</code>, which writes the output during dynamic simulations. So, let's define a custom <code><a class="el" href="classmy_g_p_solver.html">myGPSolver</a></code> class, inheriting from <code><a class="el" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html" title="Class to solve the Gross-Pitaevskii equation.">UltraCold::GPSolvers::GPSolver</a></code>, and overriding the member functions described above:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_class" href="classmy_g_p_solver.html">myGPSolver</a> : <span class="keyword">public</span> <a class="code hl_class" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html">GPSolvers::GPSolver</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">using </span>GPSolver::GPSolver;</div>
<div class="line">        <span class="keywordtype">void</span> <a class="code hl_function" href="classmy_g_p_solver.html#af19bbeea74599e536053aa471effb0bf">run_operator_splitting</a>(<span class="keywordtype">int</span> number_of_time_steps,</div>
<div class="line">                                    <span class="keywordtype">double</span> time_step,</div>
<div class="line">                                    <span class="keywordtype">double</span> ramp_duration,</div>
<div class="line">                                    <span class="keywordtype">double</span> initial_scattering_length,</div>
<div class="line">                                    <span class="keywordtype">double</span> final_scattering_length,</div>
<div class="line">                                    std::ostream&amp; output_stream) <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">void</span> <a class="code hl_function" href="classmy_g_p_solver.html#ad6c9b6b574baa6241531383bddecf1e5">write_operator_splitting_output</a>(<span class="keywordtype">size_t</span> iteration_number,</div>
<div class="line">                                             <span class="keywordtype">double</span> current_scattering_length,</div>
<div class="line">                                             std::ostream&amp; output_stream) <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">protected</span>:</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">void</span> <a class="code hl_function" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#a86695841c57f5a9a0eb05c9876babf15">solve_step_1_operator_splitting</a>(<span class="keywordtype">double</span> current_scattering_length) <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line">};</div>
<div class="ttc" id="aclass_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver_html"><div class="ttname"><a href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html">UltraCold::GPSolvers::GPSolver</a></div><div class="ttdoc">Class to solve the Gross-Pitaevskii equation.</div><div class="ttdef"><b>Definition:</b> GPSolvers.hpp:156</div></div>
<div class="ttc" id="aclass_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver_html_a86695841c57f5a9a0eb05c9876babf15"><div class="ttname"><a href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#a86695841c57f5a9a0eb05c9876babf15">UltraCold::GPSolvers::GPSolver::solve_step_1_operator_splitting</a></div><div class="ttdeci">virtual void solve_step_1_operator_splitting()</div><div class="ttdoc">Solve step-1 of operator splitting.</div><div class="ttdef"><b>Definition:</b> GPSolver.cpp:589</div></div>
<div class="ttc" id="aclassmy_g_p_solver_html"><div class="ttname"><a href="classmy_g_p_solver.html">myGPSolver</a></div><div class="ttdef"><b>Definition:</b> example-1.cpp:30</div></div>
<div class="ttc" id="aclassmy_g_p_solver_html_ad6c9b6b574baa6241531383bddecf1e5"><div class="ttname"><a href="classmy_g_p_solver.html#ad6c9b6b574baa6241531383bddecf1e5">myGPSolver::write_operator_splitting_output</a></div><div class="ttdeci">void write_operator_splitting_output(size_t iteration_number, double current_scattering_length, std::ostream &amp;output_stream) override</div><div class="ttdoc">Useful possible overload.</div><div class="ttdef"><b>Definition:</b> example-1.cpp:114</div></div>
<div class="ttc" id="aclassmy_g_p_solver_html_af19bbeea74599e536053aa471effb0bf"><div class="ttname"><a href="classmy_g_p_solver.html#af19bbeea74599e536053aa471effb0bf">myGPSolver::run_operator_splitting</a></div><div class="ttdeci">void run_operator_splitting(int number_of_time_steps, double time_step, double ramp_duration, double initial_scattering_length, double final_scattering_length, std::ostream &amp;output_stream) override</div><div class="ttdoc">Useful possible overload.</div><div class="ttdef"><b>Definition:</b> example-1.cpp:51</div></div>
</div><!-- fragment --><p >First, we override <code>run_operator_splitting(...)</code> in such a way that it takes, as arguments, the duration of the ramp in the scattering length, as well as the values of the initial and final scattering lengths. The function will also perform a linear ramp in the scattering length during the real-time evolution of the system. Notice that the operator splitting procedure is here explicitly implemented, with the laplacian calculated using the Fast Fourier Transform routines from the Intel's Math Kernel Library, wrapped in the class <code>MKLWrappers::DFtCalculator</code>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="classmy_g_p_solver.html#af19bbeea74599e536053aa471effb0bf">myGPSolver::run_operator_splitting</a>(<span class="keywordtype">int</span> number_of_time_steps,</div>
<div class="line">                                        <span class="keywordtype">double</span> time_step,</div>
<div class="line">                                        <span class="keywordtype">double</span> ramp_duration,</div>
<div class="line">                                        <span class="keywordtype">double</span> initial_scattering_length,</div>
<div class="line">                                        <span class="keywordtype">double</span> final_scattering_length,</div>
<div class="line">                                        std::ostream &amp;output_stream)</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Initialize the member variable time_step</span></div>
<div class="line"> </div>
<div class="line">    this-&gt;time_step = time_step;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Since the G.P. equation is solved on a cartesian mesh with periodic boundary conditions, a</span></div>
<div class="line">    <span class="comment">// DFtCalculator is needed to calculate the laplacian of psi</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_m_k_l_wrappers_1_1_d_ft_calculator.html">MKLWrappers::DFtCalculator</a> dft_calculator_step_2(psi,psitilde);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//----------------------------------------------------//</span></div>
<div class="line">    <span class="comment">//    Here the operator-splitting iterations start    //</span></div>
<div class="line">    <span class="comment">//----------------------------------------------------//</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> current_scattering_length=initial_scattering_length;</div>
<div class="line">    <span class="keywordtype">double</span> current_time=0;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> iteration_number = 0; iteration_number &lt; number_of_time_steps; ++iteration_number)</div>
<div class="line">    {</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Write outputs starting from the first time step</span></div>
<div class="line"> </div>
<div class="line">        <a class="code hl_function" href="classmy_g_p_solver.html#ad6c9b6b574baa6241531383bddecf1e5">write_operator_splitting_output</a>(iteration_number,</div>
<div class="line">                                        current_scattering_length,</div>
<div class="line">                                        output_stream);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Update the current value of the scattering length</span></div>
<div class="line"> </div>
<div class="line">        current_time = iteration_number*time_step;</div>
<div class="line">        <span class="keywordflow">if</span>(current_time &lt;= ramp_duration)</div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt; current_scattering_length*20361.7&lt;&lt; std::endl;</div>
<div class="line">            current_scattering_length = initial_scattering_length</div>
<div class="line">                                        + (final_scattering_length-initial_scattering_length) * current_time/ramp_duration;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Solve step 1 of operator splitting</span></div>
<div class="line"> </div>
<div class="line">        <a class="code hl_function" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#a86695841c57f5a9a0eb05c9876babf15">solve_step_1_operator_splitting</a>(current_scattering_length);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Solve step 2 of operator splitting</span></div>
<div class="line"> </div>
<div class="line">        <a class="code hl_function" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#a89dd0f90d9f3db9cbee73b388389b9b4">solve_step_2_operator_splitting</a>(dft_calculator_step_2);</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="aclass_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver_html_a89dd0f90d9f3db9cbee73b388389b9b4"><div class="ttname"><a href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#a89dd0f90d9f3db9cbee73b388389b9b4">UltraCold::GPSolvers::GPSolver::solve_step_2_operator_splitting</a></div><div class="ttdeci">void solve_step_2_operator_splitting(MKLWrappers::DFtCalculator &amp;)</div><div class="ttdoc">Solve step-2 of operator splitting.</div><div class="ttdef"><b>Definition:</b> GPSolver.cpp:629</div></div>
<div class="ttc" id="aclass_ultra_cold_1_1_m_k_l_wrappers_1_1_d_ft_calculator_html"><div class="ttname"><a href="class_ultra_cold_1_1_m_k_l_wrappers_1_1_d_ft_calculator.html">UltraCold::MKLWrappers::DFtCalculator</a></div><div class="ttdoc">Class to calculate Fourier transforms using Intel's MKL DFT functions.</div><div class="ttdef"><b>Definition:</b> DFtCalculator.hpp:59</div></div>
</div><!-- fragment --><p >Then, we also override the member function that solves the first step of the operator-splitting method in such a way that it uses the current value of the scattering length. Since we like to go fast, we also add a simple pre-processor directive instructing the compiler to parallelize the loop using OpenMP:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#a86695841c57f5a9a0eb05c9876babf15">myGPSolver::solve_step_1_operator_splitting</a>(<span class="keywordtype">double</span> current_scattering_length)</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#pragma omp parallel for</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.<a class="code hl_function" href="class_ultra_cold_1_1_vector.html#a28432f7d508af676536782d2a34dca05">size</a>(); ++i)</div>
<div class="line">            psi(i) *= std::exp(-ci*time_step*(Vext(i)+ 4*PI*current_scattering_length*std::norm(psi(i))));</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="aclass_ultra_cold_1_1_vector_html_a28432f7d508af676536782d2a34dca05"><div class="ttname"><a href="class_ultra_cold_1_1_vector.html#a28432f7d508af676536782d2a34dca05">UltraCold::Vector::size</a></div><div class="ttdeci">int size()</div><div class="ttdoc">Get the total number of elements.</div><div class="ttdef"><b>Definition:</b> Vector.cpp:266</div></div>
</div><!-- fragment --><p >Finally, we override the member function that writes the output of the real-time simulation, in such a way that it will calculate the root mean-squared radius of the atomic cloud every hundred time steps, writing it to the output stream together with the current time. Once again, since we like to go fast, we add a <code>#pragma</code> to parallelize the triple loop using OpenMP. Notice that both the time and the root mean squared radius will be in harmonic units:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="classmy_g_p_solver.html#ad6c9b6b574baa6241531383bddecf1e5">myGPSolver::write_operator_splitting_output</a>(<span class="keywordtype">size_t</span> iteration_number,</div>
<div class="line">                                                 <span class="keywordtype">double</span> current_scattering_length,</div>
<div class="line">                                                 std::ostream &amp;output_stream)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span>(iteration_number % 100 == 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">double</span> r2m = 0.0;</div>
<div class="line">        <span class="keywordtype">double</span> norm = 0.0;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#pragma omp parallel for reduction(+: r2m,norm) collapse(3)</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.<a class="code hl_function" href="class_ultra_cold_1_1_vector.html#a255ce5c3acc5afceb2052d9eb3f338a3">extent</a>(0); ++i)</div>
<div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> j = 0; j &lt; psi.<a class="code hl_function" href="class_ultra_cold_1_1_vector.html#a255ce5c3acc5afceb2052d9eb3f338a3">extent</a>(1); ++j)</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k = 0; k &lt; psi.<a class="code hl_function" href="class_ultra_cold_1_1_vector.html#a255ce5c3acc5afceb2052d9eb3f338a3">extent</a>(2); ++k)</div>
<div class="line">                {</div>
<div class="line">                    r2m += (std::pow(x[i],2)+std::pow(y[j],2)+std::pow(z[k],2))*std::norm(psi(i,j,k));</div>
<div class="line">                    norm += std::norm(psi(i,j,k));</div>
<div class="line">                }</div>
<div class="line">        r2m = std::sqrt(r2m/norm);</div>
<div class="line">        output_stream &lt;&lt; iteration_number*time_step &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; current_scattering_length &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; r2m &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_ultra_cold_1_1_vector_html_a255ce5c3acc5afceb2052d9eb3f338a3"><div class="ttname"><a href="class_ultra_cold_1_1_vector.html#a255ce5c3acc5afceb2052d9eb3f338a3">UltraCold::Vector::extent</a></div><div class="ttdeci">int extent(int)</div><div class="ttdoc">Get the extent of the Vector along a certain direction.</div><div class="ttdef"><b>Definition:</b> Vector.cpp:291</div></div>
</div><!-- fragment --><p >Now, we can define our main function.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main() {</div>
</div><!-- fragment --><p >The first thing that main does is to define an object ot type <code><a class="el" href="class_ultra_cold_1_1_tools_1_1_input_parser.html" title="Class to read input parameters from files.">UltraCold::Tools::InputParser</a></code>, which allows to read the parameters defined in the file <code>example-1.prm</code> as follows:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_ultra_cold_1_1_tools_1_1_input_parser.html">Tools::InputParser</a> ip(<span class="stringliteral">&quot;example-1.prm&quot;</span>);</div>
<div class="line"> </div>
<div class="line">ip.read_input_file();</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> xmax = ip.retrieve_double(<span class="stringliteral">&quot;xmax&quot;</span>);</div>
<div class="line"><span class="keywordtype">double</span> ymax = ip.retrieve_double(<span class="stringliteral">&quot;ymax&quot;</span>);</div>
<div class="line"><span class="keywordtype">double</span> zmax = ip.retrieve_double(<span class="stringliteral">&quot;zmax&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> nx = ip.retrieve_int(<span class="stringliteral">&quot;nx&quot;</span>);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> ny = ip.retrieve_int(<span class="stringliteral">&quot;ny&quot;</span>);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> nz = ip.retrieve_int(<span class="stringliteral">&quot;nz&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> initial_scattering_length = ip.retrieve_double(<span class="stringliteral">&quot;initial scattering length&quot;</span>);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span>    number_of_particles = ip.retrieve_int(<span class="stringliteral">&quot;number of particles&quot;</span>);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> atomic_mass         = ip.retrieve_double(<span class="stringliteral">&quot;atomic mass&quot;</span>);</div>
<div class="line"><span class="keywordtype">double</span> omegax                    = ip.retrieve_double(<span class="stringliteral">&quot;omegax&quot;</span>);</div>
<div class="line"><span class="keywordtype">double</span> omegay                    = ip.retrieve_double(<span class="stringliteral">&quot;omegay&quot;</span>);</div>
<div class="line"><span class="keywordtype">double</span> omegaz                    = ip.retrieve_double(<span class="stringliteral">&quot;omegaz&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span>    number_of_gradient_descent_steps = ip.retrieve_int(<span class="stringliteral">&quot;number of gradient descent steps&quot;</span>);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> residual                         = ip.retrieve_double(<span class="stringliteral">&quot;residual&quot;</span>);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> alpha                            = ip.retrieve_double(<span class="stringliteral">&quot;alpha&quot;</span>);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> beta                             = ip.retrieve_double(<span class="stringliteral">&quot;beta&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span>    number_of_real_time_steps = ip.retrieve_int(<span class="stringliteral">&quot;number of real time steps&quot;</span>);</div>
<div class="line"><span class="keywordtype">double</span> time_step                       = ip.retrieve_double(<span class="stringliteral">&quot;time step&quot;</span>);</div>
<div class="line"><span class="keywordtype">double</span> final_scattering_length         = ip.retrieve_double(<span class="stringliteral">&quot;final scattering length&quot;</span>);</div>
<div class="line"><span class="keywordtype">double</span> ramp_duration                   = ip.retrieve_double(<span class="stringliteral">&quot;ramp duration&quot;</span>);</div>
<div class="ttc" id="aclass_ultra_cold_1_1_tools_1_1_input_parser_html"><div class="ttname"><a href="class_ultra_cold_1_1_tools_1_1_input_parser.html">UltraCold::Tools::InputParser</a></div><div class="ttdoc">Class to read input parameters from files.</div><div class="ttdef"><b>Definition:</b> InputParser.hpp:93</div></div>
</div><!-- fragment --><p >Since it is very useful for comparison with typical scales used in experiments, in the input we gave lengths in micrometers, the scattering length in units of the Bohr radius, the time-step in milliseconds, and the atomic mass in atomic mass units. It is time to convert these parameters into harmonic units, in order to map them to an a-dimensional Gross-Pitaevskii equation:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> hbar        = 0.6347*1.E5;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> bohr_radius = 5.292E-5;</div>
<div class="line"> </div>
<div class="line">omegax *= TWOPI;</div>
<div class="line">omegay *= TWOPI;</div>
<div class="line">omegaz *= TWOPI;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> omega_ho = std::cbrt(omegax*omegay*omegaz);</div>
<div class="line"> </div>
<div class="line">time_step     = time_step*omega_ho/1000.0;</div>
<div class="line">ramp_duration = ramp_duration*omega_ho/1000.0;</div>
<div class="line"> </div>
<div class="line">omegax = omegax/omega_ho;</div>
<div class="line">omegay = omegay/omega_ho;</div>
<div class="line">omegaz = omegaz/omega_ho;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> a_ho = std::sqrt(hbar/(atomic_mass*omega_ho));</div>
<div class="line"> </div>
<div class="line">initial_scattering_length *= bohr_radius/a_ho;</div>
<div class="line">final_scattering_length   *= bohr_radius/a_ho;</div>
<div class="line"> </div>
<div class="line">xmax = xmax/a_ho;</div>
<div class="line">ymax = ymax/a_ho;</div>
<div class="line">zmax = zmax/a_ho;</div>
</div><!-- fragment --><p >We can now define the three-dimensional mesh on which the equation will be solved</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> x(nx);</div>
<div class="line"><a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> y(ny);</div>
<div class="line"><a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> z(nz);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> dx = 2.*xmax/nx;</div>
<div class="line"><span class="keywordtype">double</span> dy = 2.*ymax/ny;</div>
<div class="line"><span class="keywordtype">double</span> dz = 2.*zmax/nz;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; nx; ++i) x(i) = -xmax + i*dx;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; ny; ++i) y(i) = -ymax + i*dy;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; nz; ++i) z(i) = -zmax + i*dz;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> dv = dx*dy*dz;</div>
<div class="ttc" id="aclass_ultra_cold_1_1_vector_html"><div class="ttname"><a href="class_ultra_cold_1_1_vector.html">UltraCold::Vector&lt; double &gt;</a></div></div>
</div><!-- fragment --><p >Next, we define an initial wave function, normalized to the total number of particles, and the external potential</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;std::complex&lt;double&gt;</a>&gt; psi(nx,ny,nz);</div>
<div class="line"><a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> Vext(nx,ny,nz);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; nx; ++i)</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; ny; ++j)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k = 0; k &lt; nz; ++k)</div>
<div class="line">        {</div>
<div class="line">            psi(i,j,k)  = exp(- (pow(x(i),2) + </div>
<div class="line">                                 pow(y(j),2) +</div>
<div class="line">                                 pow(z(k),2)) );</div>
<div class="line"> </div>
<div class="line">            Vext(i,j,k) = 0.5*( std::pow(omegax,2)*pow(x(i),2) + </div>
<div class="line">                                std::pow(omegay,2)*pow(y(j),2) + </div>
<div class="line">                                std::pow(omegaz,2)*pow(z(k),2) );       </div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> norm = 0.0;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) norm += std::norm(psi[i]);</div>
<div class="line">norm *= dv;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) psi[i] *= std::sqrt(number_of_particles/norm);</div>
</div><!-- fragment --><p >Finally, we initialize the <code><a class="el" href="classmy_g_p_solver.html">myGPSolver</a></code> class, and run the <code>run_gradient_descent(...)</code> member function in order to calculate a ground state solution on the defined mesh and for this external potential and physical parameters:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classmy_g_p_solver.html">myGPSolver</a> gp_solver(x,y,z,psi,Vext,initial_scattering_length);</div>
<div class="line"> </div>
<div class="line">std::fstream gradient_descent_output_stream;</div>
<div class="line">gradient_descent_output_stream.open(<span class="stringliteral">&quot;gradient_descent_output.csv&quot;</span>,std::ios::out);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> chemical_potential;</div>
<div class="line">std::tie(psi,chemical_potential) = gp_solver.run_gradient_descent(number_of_gradient_descent_steps,</div>
<div class="line">                                                                  residual,</div>
<div class="line">                                                                  alpha,</div>
<div class="line">                                                                  beta,</div>
<div class="line">                                                                  gradient_descent_output_stream);</div>
<div class="line"> </div>
<div class="line">gradient_descent_output_stream.close();</div>
</div><!-- fragment --><p >We write our ground state solution to a .vtk file, that can be read for plotting using programs like <a href="https://www.paraview.org/">Paraview </a> or <a href="https://visit-dav.github.io/visit-website/index.html">Visit</a>, using the class <code>UltraCold::RealSpaceOut::DataOut</code>:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_ultra_cold_1_1_real_space_output_1_1_data_out.html">RealSpaceOutput::DataOut</a> data_out;</div>
<div class="line">data_out.<a class="code hl_function" href="class_ultra_cold_1_1_real_space_output_1_1_data_out.html#acb4c018af1f731035d492cdccdb49b45">set_output_name</a>(<span class="stringliteral">&quot;ground_state_wave_function&quot;</span>);</div>
<div class="line">data_out.<a class="code hl_function" href="class_ultra_cold_1_1_real_space_output_1_1_data_out.html#af8e7d71fa2f88a7405bbd24843125747">write_vtk</a>(x,y,z,psi,<span class="stringliteral">&quot;psi&quot;</span>);</div>
<div class="ttc" id="aclass_ultra_cold_1_1_real_space_output_1_1_data_out_html"><div class="ttname"><a href="class_ultra_cold_1_1_real_space_output_1_1_data_out.html">UltraCold::RealSpaceOutput::DataOut</a></div><div class="ttdoc">A class to output a data Vector in real space.</div><div class="ttdef"><b>Definition:</b> DataOut.hpp:70</div></div>
<div class="ttc" id="aclass_ultra_cold_1_1_real_space_output_1_1_data_out_html_acb4c018af1f731035d492cdccdb49b45"><div class="ttname"><a href="class_ultra_cold_1_1_real_space_output_1_1_data_out.html#acb4c018af1f731035d492cdccdb49b45">UltraCold::RealSpaceOutput::DataOut::set_output_name</a></div><div class="ttdeci">void set_output_name(const std::string &amp;output_file_name)</div><div class="ttdoc">Set the name for the output data file, input as an std::string.</div><div class="ttdef"><b>Definition:</b> DataOut.cpp:30</div></div>
<div class="ttc" id="aclass_ultra_cold_1_1_real_space_output_1_1_data_out_html_af8e7d71fa2f88a7405bbd24843125747"><div class="ttname"><a href="class_ultra_cold_1_1_real_space_output_1_1_data_out.html#af8e7d71fa2f88a7405bbd24843125747">UltraCold::RealSpaceOutput::DataOut::write_vtk</a></div><div class="ttdeci">void write_vtk(Vector&lt; double &gt; &amp;x_axis, Vector&lt; double &gt; &amp;y_axis, Vector&lt; double &gt; &amp;real_output_vector, const char *vector_name)</div><div class="ttdoc">Write an output data file in .vtk format, for real 2D output.</div><div class="ttdef"><b>Definition:</b> DataOut.cpp:1498</div></div>
</div><!-- fragment --><p >Finally, we re-initialize the solver, using as initial condition the ground state solution just calculated and run the dynamic simulation</p>
<div class="fragment"><div class="line">    gp_solver.reinit(Vext,psi);</div>
<div class="line"> </div>
<div class="line">    std::fstream output_file_stream;</div>
<div class="line">    output_file_stream.open(<span class="stringliteral">&quot;real_time_output.csv&quot;</span>,std::ios::out);</div>
<div class="line"> </div>
<div class="line">    gp_solver.run_operator_splitting(number_of_real_time_steps,</div>
<div class="line">                                     time_step,</div>
<div class="line">                                     ramp_duration,</div>
<div class="line">                                     initial_scattering_length,</div>
<div class="line">                                     final_scattering_length,</div>
<div class="line">                                     output_file_stream);</div>
<div class="line"> </div>
<div class="line">    output_file_stream.close();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="Results-1"></a>
Results</h2>
<p >The ground state density profile can be visualized by opening the output file <code>ground_state_wave_function.vtk</code>, where we saved the mesh as well as the real and the imaginary part of the calculated ground-state wave function. Using, for example, <a href="https://www.paraview.org/">Paraview </a>, a typical output can look like the following</p>
<div class="image">
<img src="example-1-density.png" alt=""/>
</div>
<p >More interesting is the output of the real-time simulation dynamics. In fact, the value of squared mean radius of the cloud shows, as expected, a first decrease during the ramp, followed by a nice and simple harmonic oscillation:</p>
<div class="image">
<img src="example-1-signal.png" alt=""/>
</div>
<p >The frequency of such harmonic oscillation can be extracted by a simple Fourier transform. The output looks like the following:</p>
<div class="image">
<img src="example-1-ft.png" alt=""/>
</div>
<p >In this image, we also report the value of the frequency of the breathing mode calculated analytically, and corresponding, for this case, to \( \sqrt{5}\omega_{ho} \). Such frequency is reported in the orange vertical line, and, as we can see, corresponds very well with the one extracted from the real time simulation.</p>
<h2><a class="anchor" id="Possibilities-1"></a>
Possible extensions</h2>
<p >This program can be used as a template for studying the ground state and the dynamics of a simple BEC in different meshes and external potentials, or by exciting different collective oscillations, as e.g. the quadrupole mode.</p>
<h2><a class="anchor" id="Uncommented-1"></a>
The plain program</h2>
<div class="fragment"><div class="line"><span class="comment">/*--------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *    This file is part of the UltraCold project.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *    UltraCold is free software: you can redistribute it and/or modify</span></div>
<div class="line"><span class="comment"> *    it under the terms of the GNU General Public License as published by</span></div>
<div class="line"><span class="comment"> *    the Free Software Foundation, either version 3 of the License, or</span></div>
<div class="line"><span class="comment"> *    any later version.</span></div>
<div class="line"><span class="comment"> *    UltraCold is distributed in the hope that it will be useful,</span></div>
<div class="line"><span class="comment"> *    but WITHOUT ANY WARRANTY; without even the implied warranty of</span></div>
<div class="line"><span class="comment"> *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></div>
<div class="line"><span class="comment"> *    GNU General Public License for more details.</span></div>
<div class="line"><span class="comment"> *    You should have received a copy of the GNU General Public License</span></div>
<div class="line"><span class="comment"> *    along with UltraCold.  If not, see &lt;https://www.gnu.org/licenses/&gt;.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *--------------------------------------------------------------------------------*/</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;UltraCold.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespace_ultra_cold.html">UltraCold</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="classmy_g_p_solver.html">myGPSolver</a> : <span class="keyword">public</span> <a class="code hl_class" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html">GPSolvers::GPSolver</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">using </span>GPSolver::GPSolver;</div>
<div class="line">        <span class="keywordtype">void</span> <a class="code hl_function" href="classmy_g_p_solver.html#af19bbeea74599e536053aa471effb0bf">run_operator_splitting</a>(<span class="keywordtype">int</span> number_of_time_steps,</div>
<div class="line">                                    <span class="keywordtype">double</span> time_step,</div>
<div class="line">                                    <span class="keywordtype">double</span> ramp_duration,</div>
<div class="line">                                    <span class="keywordtype">double</span> initial_scattering_length,</div>
<div class="line">                                    <span class="keywordtype">double</span> final_scattering_length,</div>
<div class="line">                                    std::ostream&amp; output_stream) <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">void</span> <a class="code hl_function" href="classmy_g_p_solver.html#ad6c9b6b574baa6241531383bddecf1e5">write_operator_splitting_output</a>(<span class="keywordtype">size_t</span> iteration_number,</div>
<div class="line">                                             <span class="keywordtype">double</span> current_scattering_length,</div>
<div class="line">                                             std::ostream&amp; output_stream) <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">protected</span>:</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">void</span> <a class="code hl_function" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#a86695841c57f5a9a0eb05c9876babf15">solve_step_1_operator_splitting</a>(<span class="keywordtype">double</span> current_scattering_length) <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="classmy_g_p_solver.html#af19bbeea74599e536053aa471effb0bf">myGPSolver::run_operator_splitting</a>(<span class="keywordtype">int</span> number_of_time_steps,</div>
<div class="line">                                        <span class="keywordtype">double</span> time_step,</div>
<div class="line">                                        <span class="keywordtype">double</span> ramp_duration,</div>
<div class="line">                                        <span class="keywordtype">double</span> initial_scattering_length,</div>
<div class="line">                                        <span class="keywordtype">double</span> final_scattering_length,</div>
<div class="line">                                        std::ostream &amp;output_stream)</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Initialize the member variable time_step</span></div>
<div class="line"> </div>
<div class="line">    this-&gt;time_step = time_step;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Since the G.P. equation is solved on a cartesian mesh with periodic boundary conditions, a</span></div>
<div class="line">    <span class="comment">// DFtCalculator is needed to calculate the laplacian of psi</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_m_k_l_wrappers_1_1_d_ft_calculator.html">MKLWrappers::DFtCalculator</a> dft_calculator_step_2(psi,psitilde);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//----------------------------------------------------//</span></div>
<div class="line">    <span class="comment">//    Here the operator-splitting iterations start    //</span></div>
<div class="line">    <span class="comment">//----------------------------------------------------//</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> current_scattering_length=initial_scattering_length;</div>
<div class="line">    <span class="keywordtype">double</span> current_time=0;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> iteration_number = 0; iteration_number &lt; number_of_time_steps; ++iteration_number)</div>
<div class="line">    {</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Write outputs starting from the first time step</span></div>
<div class="line"> </div>
<div class="line">        <a class="code hl_function" href="classmy_g_p_solver.html#ad6c9b6b574baa6241531383bddecf1e5">write_operator_splitting_output</a>(iteration_number,</div>
<div class="line">                                        current_scattering_length,</div>
<div class="line">                                        output_stream);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Update the current value of the scattering length</span></div>
<div class="line"> </div>
<div class="line">        current_time = iteration_number*time_step;</div>
<div class="line">        <span class="keywordflow">if</span>(current_time &lt;= ramp_duration)</div>
<div class="line">        {</div>
<div class="line"> </div>
<div class="line">            current_scattering_length = initial_scattering_length</div>
<div class="line">                    + (final_scattering_length-initial_scattering_length) * current_time/ramp_duration;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Solve step 1 of operator splitting</span></div>
<div class="line"> </div>
<div class="line">        <a class="code hl_function" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#a86695841c57f5a9a0eb05c9876babf15">solve_step_1_operator_splitting</a>(current_scattering_length);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Solve step 2 of operator splitting</span></div>
<div class="line"> </div>
<div class="line">        <a class="code hl_function" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#a89dd0f90d9f3db9cbee73b388389b9b4">solve_step_2_operator_splitting</a>(dft_calculator_step_2);</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_ultra_cold_1_1_g_p_solvers_1_1_g_p_solver.html#a86695841c57f5a9a0eb05c9876babf15">myGPSolver::solve_step_1_operator_splitting</a>(<span class="keywordtype">double</span> current_scattering_length)</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#pragma omp parallel for</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.<a class="code hl_function" href="class_ultra_cold_1_1_vector.html#a28432f7d508af676536782d2a34dca05">size</a>(); ++i)</div>
<div class="line">            psi(i) *= std::exp(-ci*time_step*(Vext(i)+ 4*PI*current_scattering_length*std::norm(psi(i))));</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="classmy_g_p_solver.html#ad6c9b6b574baa6241531383bddecf1e5">myGPSolver::write_operator_splitting_output</a>(<span class="keywordtype">size_t</span> iteration_number,</div>
<div class="line">                                                 <span class="keywordtype">double</span> current_scattering_length,</div>
<div class="line">                                                 std::ostream &amp;output_stream)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span>(iteration_number % 100 == 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">double</span> r2m = 0.0;</div>
<div class="line">        <span class="keywordtype">double</span> norm = 0.0;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#pragma omp parallel for reduction(+: r2m,norm) collapse(3)</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.<a class="code hl_function" href="class_ultra_cold_1_1_vector.html#a255ce5c3acc5afceb2052d9eb3f338a3">extent</a>(0); ++i)</div>
<div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> j = 0; j &lt; psi.<a class="code hl_function" href="class_ultra_cold_1_1_vector.html#a255ce5c3acc5afceb2052d9eb3f338a3">extent</a>(1); ++j)</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k = 0; k &lt; psi.<a class="code hl_function" href="class_ultra_cold_1_1_vector.html#a255ce5c3acc5afceb2052d9eb3f338a3">extent</a>(2); ++k)</div>
<div class="line">                {</div>
<div class="line">                    r2m += (std::pow(x[i],2)+std::pow(y[j],2)+std::pow(z[k],2))*std::norm(psi(i,j,k));</div>
<div class="line">                    norm += std::norm(psi(i,j,k));</div>
<div class="line">                }</div>
<div class="line">        r2m = std::sqrt(r2m/norm);</div>
<div class="line">        output_stream &lt;&lt; iteration_number*time_step &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; current_scattering_length &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; r2m &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_tools_1_1_input_parser.html">Tools::InputParser</a> ip(<span class="stringliteral">&quot;../example-1.prm&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    ip.read_input_file();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> xmax = ip.retrieve_double(<span class="stringliteral">&quot;xmax&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> ymax = ip.retrieve_double(<span class="stringliteral">&quot;ymax&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> zmax = ip.retrieve_double(<span class="stringliteral">&quot;zmax&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> nx = ip.retrieve_int(<span class="stringliteral">&quot;nx&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> ny = ip.retrieve_int(<span class="stringliteral">&quot;ny&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> nz = ip.retrieve_int(<span class="stringliteral">&quot;nz&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> initial_scattering_length = ip.retrieve_double(<span class="stringliteral">&quot;initial scattering length&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>    number_of_particles = ip.retrieve_int(<span class="stringliteral">&quot;number of particles&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> atomic_mass         = ip.retrieve_double(<span class="stringliteral">&quot;atomic mass&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> omegax                    = ip.retrieve_double(<span class="stringliteral">&quot;omegax&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> omegay                    = ip.retrieve_double(<span class="stringliteral">&quot;omegay&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> omegaz                    = ip.retrieve_double(<span class="stringliteral">&quot;omegaz&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>    number_of_gradient_descent_steps = ip.retrieve_int(<span class="stringliteral">&quot;number of gradient descent steps&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> residual                         = ip.retrieve_double(<span class="stringliteral">&quot;residual&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> alpha                            = ip.retrieve_double(<span class="stringliteral">&quot;alpha&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> beta                             = ip.retrieve_double(<span class="stringliteral">&quot;beta&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>    number_of_real_time_steps = ip.retrieve_int(<span class="stringliteral">&quot;number of real time steps&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> time_step                       = ip.retrieve_double(<span class="stringliteral">&quot;time step&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> final_scattering_length         = ip.retrieve_double(<span class="stringliteral">&quot;final scattering length&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> ramp_duration                   = ip.retrieve_double(<span class="stringliteral">&quot;ramp duration&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> hbar        = 0.6347*1.E5;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> bohr_radius = 5.292E-5;</div>
<div class="line"> </div>
<div class="line">    omegax *= TWOPI;</div>
<div class="line">    omegay *= TWOPI;</div>
<div class="line">    omegaz *= TWOPI;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> omega_ho = std::cbrt(omegax*omegay*omegaz);</div>
<div class="line"> </div>
<div class="line">    time_step     = time_step*omega_ho/1000.0;</div>
<div class="line">    ramp_duration = ramp_duration*omega_ho/1000.0;</div>
<div class="line"> </div>
<div class="line">    omegax = omegax/omega_ho;</div>
<div class="line">    omegay = omegay/omega_ho;</div>
<div class="line">    omegaz = omegaz/omega_ho;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> a_ho = std::sqrt(hbar/(atomic_mass*omega_ho));</div>
<div class="line"> </div>
<div class="line">    initial_scattering_length *= bohr_radius/a_ho;</div>
<div class="line">    final_scattering_length   *= bohr_radius/a_ho;</div>
<div class="line"> </div>
<div class="line">    xmax = xmax/a_ho;</div>
<div class="line">    ymax = ymax/a_ho;</div>
<div class="line">    zmax = zmax/a_ho;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> x(nx);</div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> y(ny);</div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> z(nz);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> dx = 2.*xmax/nx;</div>
<div class="line">    <span class="keywordtype">double</span> dy = 2.*ymax/ny;</div>
<div class="line">    <span class="keywordtype">double</span> dz = 2.*zmax/nz;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; nx; ++i) x(i) = -xmax + i*dx;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; ny; ++i) y(i) = -ymax + i*dy;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; nz; ++i) z(i) = -zmax + i*dz;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> dv = dx*dy*dz;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;std::complex&lt;double&gt;</a>&gt; psi(nx,ny,nz);</div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> Vext(nx,ny,nz);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; nx; ++i)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; ny; ++j)</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k = 0; k &lt; nz; ++k)</div>
<div class="line">            {</div>
<div class="line">                psi(i,j,k)  = exp(- (pow(x(i),2) +</div>
<div class="line">                                     pow(y(j),2) +</div>
<div class="line">                                     pow(z(k),2)) );</div>
<div class="line"> </div>
<div class="line">                Vext(i,j,k) = 0.5*( std::pow(omegax,2)*pow(x(i),2) +</div>
<div class="line">                                    std::pow(omegay,2)*pow(y(j),2) +</div>
<div class="line">                                    std::pow(omegaz,2)*pow(z(k),2) );</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> norm = 0.0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) norm += std::norm(psi[i]);</div>
<div class="line">    norm *= dv;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) psi[i] *= std::sqrt(number_of_particles/norm);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classmy_g_p_solver.html">myGPSolver</a> gp_solver(x,y,z,psi,Vext,initial_scattering_length);</div>
<div class="line"> </div>
<div class="line">    std::fstream gradient_descent_output_stream;</div>
<div class="line">    gradient_descent_output_stream.open(<span class="stringliteral">&quot;gradient_descent_output.csv&quot;</span>,std::ios::out);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> chemical_potential;</div>
<div class="line">    std::tie(psi,chemical_potential) = gp_solver.run_gradient_descent(number_of_gradient_descent_steps,</div>
<div class="line">                                                                      residual,</div>
<div class="line">                                                                      alpha,</div>
<div class="line">                                                                      beta,</div>
<div class="line">                                                                      gradient_descent_output_stream);</div>
<div class="line"> </div>
<div class="line">    gradient_descent_output_stream.close();</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_real_space_output_1_1_data_out.html">RealSpaceOutput::DataOut</a> data_out;</div>
<div class="line">    data_out.<a class="code hl_function" href="class_ultra_cold_1_1_real_space_output_1_1_data_out.html#acb4c018af1f731035d492cdccdb49b45">set_output_name</a>(<span class="stringliteral">&quot;ground_state_wave_function&quot;</span>);</div>
<div class="line">    data_out.<a class="code hl_function" href="class_ultra_cold_1_1_real_space_output_1_1_data_out.html#af8e7d71fa2f88a7405bbd24843125747">write_vtk</a>(x,y,z,psi,<span class="stringliteral">&quot;psi&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    gp_solver.reinit(Vext,psi);</div>
<div class="line"> </div>
<div class="line">    std::fstream output_file_stream;</div>
<div class="line">    output_file_stream.open(<span class="stringliteral">&quot;real_time_output.csv&quot;</span>,std::ios::out);</div>
<div class="line"> </div>
<div class="line">    gp_solver.run_operator_splitting(number_of_real_time_steps,</div>
<div class="line">                                     time_step,</div>
<div class="line">                                     ramp_duration,</div>
<div class="line">                                     initial_scattering_length,</div>
<div class="line">                                     final_scattering_length,</div>
<div class="line">                                     output_file_stream);</div>
<div class="line"> </div>
<div class="line">    output_file_stream.close();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UltraCold: example-3</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/SVG"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">UltraCold
   </div>
   <div id="projectbrief">Collection of C++ libraries for the study of ultra-cold systems in the context of Gross-Pitaevskii theory</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('example-3.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">example-3 </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Title-3">A three-dimensional dipolar Bose gas in a harmonic trap.</a><ul><li class="level2"><a href="#Introduction-3">Introduction</a></li>
<li class="level2"><a href="#What-3">Program description</a></li>
<li class="level2"><a href="#Results-3">Results</a></li>
<li class="level2"><a href="#Possibilities-3">Possible extensions</a></li>
<li class="level2"><a href="#Uncommented-3">The plain program</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Santo Maria Roccuzzo (<a href="#" onclick="location.href='mai'+'lto:'+'san'+'to'+'m.r'+'oc'+'cuz'+'zo'+'@gm'+'ai'+'l.c'+'om'; return false;">santo<span class="obfuscator">.nosp@m.</span>m.ro<span class="obfuscator">.nosp@m.</span>ccuzz<span class="obfuscator">.nosp@m.</span>o@gm<span class="obfuscator">.nosp@m.</span>ail.c<span class="obfuscator">.nosp@m.</span>om</a>)</dd></dl>
<h1><a class="anchor" id="Title-3"></a>
A three-dimensional dipolar Bose gas in a harmonic trap.</h1>
<h2><a class="anchor" id="Introduction-3"></a>
Introduction</h2>
<p >In this example, we are going to use UltraCold to study the ground state of a three-dimensional, harmonically trapped <b>dipolar</b> Bose gas of \( ^{164}Dy \) atoms, using the solver class <code><a class="el" href="class_ultra_cold_1_1_g_p_solvers_1_1_dipolar_g_p_solver.html" title="Class to solve the Gross-Pitaevskii equation for a dipolar Bose gas in two or three space dimensions.">UltraCold::GPSolvers::DipolarGPSolver</a></code>.</p>
<p >Bose-Einstein condensates have been obtained in atomic species, like <a href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.108.210401">Erbium </a> or <a href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.107.190401">Dysprosium </a>, possessing a strong magnetic dipole moment in their ground state. This implies that, in order to describe the physics of such BECs, it is necessary to take into account the effect of magnetic interactions between the atoms. In the typical setup, atoms are aligned along a certain direction (say, the x-axis) by an external magnetic field, and their dipole-dipole interaction potential has the form</p>
<p >$$ V_{dd}({\bf r}-{\bf r}') = \frac{\mu_0\mu^2}{4\pi}\frac{1-3\cos^2(\theta)}{|{\bf r}-{\bf r}'|^3} $$</p>
<p >with \( \mu_0 \) the magnetic permeability in vacuum, \( \mu \) the magnetic dipole moment and \( \theta \) the angle between the vector distance between dipoles and the polarization direction, i.e. in this case the \( x \)-axis. A simple mean-field description has been shown to fail in describing the observed properties of dipolar BECs. Currently, the most commonly used model for the description of dipolar BECs takes into account the first-order beyond mean-field correction to the ground-state energy of the system in the local density approximation. Such <a href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.86.063609">Lee-Huang-Yang </a> (LHY) correction for a uniform system is given by</p>
<p class="formulaDsp">
\[
 \frac{E_0}{V}=\frac{1}{2}gn^2\left[1+\frac{128}{15\sqrt{\pi}}\sqrt{na^3}F(\epsilon_{dd})\right]
\]
</p>
<p> with </p><p class="formulaDsp">
\[
 F(\epsilon_{dd})=\frac{1}{2}\int_0^{\pi}d\theta sin\theta[1+\epsilon_{dd}(3cos^2\theta-1)]^{\frac{5}{2}}
\]
</p>
<p >Inserting this correction in the local density approximation in a mean-field model, we obtain the extended Gross-Pitaevskii equation</p>
<p class="formulaDsp">
\[
\begin{align}
 &amp;i\hbar\frac{\partial}{\partial t}  \Psi({\bf r},t)= \mathcal{H}({\bf r})\,\Psi({\bf r},t)\,,
\end{align}
\]
</p>
<p >where the Hamiltonian \( H \) is</p>
<p class="formulaDsp">
\[
 \begin{align}
  \mathcal{H}({\bf r})=-&amp;\frac{\hbar^2}{2m}\nabla^2+V_{\rm ext}({\bf r})+g|\Psi({\bf r},t)|^2+\gamma
  (\varepsilon_{dd})|\Psi({\bf r},t)|^3\nonumber\\
  +&amp; \int d{\bf r&#39;}V_{dd}({\bf r}-{\bf r&#39;})|\Psi({\bf r&#39;},t)|^2\,,
 \end{align}
\]
</p>
<p >with \( g=4\pi\hbar^2a/m \) the coupling constant fixed by the \( s \)-wave scattering length \( a \) and</p>
<p class="formulaDsp">
\[
 \gamma(\varepsilon_{dd})=\frac{16}{3\sqrt{\pi}} ga^{\frac{3}{2}}\,\mbox{Re}\bigg[\!\int_0^{\pi}
 \!\!\!\!d\theta\sin\theta [1+\varepsilon_{dd}(3\cos^2\theta-1)]^{\frac{5}{2}}\bigg]\,.
\]
</p>
<p >In the absence of trapping, the system can be fully characterised by the single parameter \( \varepsilon_{dd}=\mu_0\mu^2/(3g)=a_{dd}/a \), i.e., the ratio between the strength of the dipolar and the contact interaction, eventually written in terms of the dipolar length \( a_{dd} \) and the scattering length \( a \).</p>
<p >Among the peculiar effects described by this model, we mention the possibility of describing the so-called <a href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.93.061603">quantum droplets </a>, i.e. ultra-dilute, self-bound, liquid-like droplets in the Bose-Einstein condensed phase, and <a href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.99.041601">supersolids </a>, i.e. phase-coherent systems spontaneously breaking translational invariance, developing spatial periodicity.</p>
<p >In this example, we will use the solver class <code><a class="el" href="class_ultra_cold_1_1_g_p_solvers_1_1_dipolar_g_p_solver.html" title="Class to solve the Gross-Pitaevskii equation for a dipolar Bose gas in two or three space dimensions.">UltraCold::GPSolvers::DipolarGPSolver</a></code> to describe a simple supersolid state of a dipolar gas in a cigar-shaped harmonic trap.</p>
<h2><a class="anchor" id="What-3"></a>
Program description</h2>
<p >We first create an input file containing our mesh and physical parameters, as well as other parameters determining the run-time behavior of the system. Such input file will be called <code>example-3.prm</code> and contains the following text</p>
<pre class="fragment"># Mesh parameters

xmax = 10.0 # Size of the mesh along the x-axis, in micrometers. The mesh will extend from -xmax to xmax
ymax = 10.0 # Size of the mesh along the y-axis, in micrometers. The mesh will extend from -ymax to ymax
zmax = 15.0 # Size of the mesh along the z-axis, in micrometers. The mesh will extend from -zmax to zmax

nx = 64 # Number of points along the x-axis
ny = 64 # Number of points along the y-axis
nz = 128 # Number of points along the z-axis

# Physical parameters

scattering length   = 95.0 # Scattering length in units of the Bohr radius
dipolar_length      = 132.0 # Dipolar length in units of the Bohr radius
number of particles = 40000  # Total number of atoms
atomic mass         = 164    # Atomic mass, in atomic mass units
omegax = 90 # Harmonic frequency along the x-axis, in units of (2pi)Hz
omegay = 60 # Harmonic frequency along the y-axis, in units of (2pi)Hz
omegaz = 30 # Harmonic frequency along the z-axis, in units of (2pi)Hz

# Run parameters for gradient descent

number of gradient descent steps = 20000 # maximum number of gradient descent steps
residual                         = 1.E-6 # Threshold on the norm of the residual
alpha                            = 1.E-3 # gradient descent step
beta                             = 0.9   # step for the heavy-ball acceleration method</pre><p >Notice that the mesh is anisotropic, as well as the harmonic trap. In particular, we are using a trap elongated along the z-axis, and tighter along the x-axis. This is because the dipoles are aligned along the x-direction, and so, due to the partially attractive nature of the dipolar potential, they will try to "pile-up" in order to reach the lower energy attractive configuration with the dipoles sitting "head-to-tail". This can be partially prevented by using a tight harmonic trap along the polarization direction. Nonetheless, in the pure mean-field picture, using these parameters, the model would not admit any stable ground-state. Practically, solving the GPe without the LHY correction for the lowest energy state would result in a collapsed state, with the full wave-function concentrated in a single point of the mesh. Instead, the LHY correction will produce an interesting and stable ground-state configuration.</p>
<p >Let's look at the program. As in previous examples, we first read our input parameter file and set harmonic units</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;UltraCold.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;random&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespace_ultra_cold.html">UltraCold</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_tools_1_1_input_parser.html">Tools::InputParser</a> ip(<span class="stringliteral">&quot;example-3.prm&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    ip.read_input_file();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> xmax = ip.retrieve_double(<span class="stringliteral">&quot;xmax&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> ymax = ip.retrieve_double(<span class="stringliteral">&quot;ymax&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> zmax = ip.retrieve_double(<span class="stringliteral">&quot;zmax&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> nx = ip.retrieve_int(<span class="stringliteral">&quot;nx&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> ny = ip.retrieve_int(<span class="stringliteral">&quot;ny&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> nz = ip.retrieve_int(<span class="stringliteral">&quot;nz&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> scattering_length         = ip.retrieve_double(<span class="stringliteral">&quot;scattering length&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> dipolar_length            = ip.retrieve_double(<span class="stringliteral">&quot;dipolar_length&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>    number_of_particles = ip.retrieve_int(<span class="stringliteral">&quot;number of particles&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> atomic_mass         = ip.retrieve_double(<span class="stringliteral">&quot;atomic mass&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> omegax                    = ip.retrieve_double(<span class="stringliteral">&quot;omegax&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> omegay                    = ip.retrieve_double(<span class="stringliteral">&quot;omegay&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> omegaz                    = ip.retrieve_double(<span class="stringliteral">&quot;omegaz&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>    number_of_gradient_descent_steps = ip.retrieve_int(<span class="stringliteral">&quot;number of gradient descent steps&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> residual                         = ip.retrieve_double(<span class="stringliteral">&quot;residual&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> alpha                            = ip.retrieve_double(<span class="stringliteral">&quot;alpha&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> beta                             = ip.retrieve_double(<span class="stringliteral">&quot;beta&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> hbar        = 0.6347*1.E5;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> bohr_radius = 5.292E-5;</div>
<div class="line"> </div>
<div class="line">    omegax *= TWOPI;</div>
<div class="line">    omegay *= TWOPI;</div>
<div class="line">    omegaz *= TWOPI;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> omega_ho = std::cbrt(omegax*omegay*omegaz);</div>
<div class="line"> </div>
<div class="line">    omegax = omegax/omega_ho;</div>
<div class="line">    omegay = omegay/omega_ho;</div>
<div class="line">    omegaz = omegaz/omega_ho;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> a_ho = std::sqrt(hbar/(atomic_mass*omega_ho));</div>
<div class="line"> </div>
<div class="line">    scattering_length *= bohr_radius/a_ho;</div>
<div class="line">    dipolar_length *= bohr_radius/a_ho;</div>
<div class="line"> </div>
<div class="line">    xmax = xmax/a_ho;</div>
<div class="line">    ymax = ymax/a_ho;</div>
<div class="line">    zmax = zmax/a_ho;</div>
<div class="ttc" id="aclass_ultra_cold_1_1_tools_1_1_input_parser_html"><div class="ttname"><a href="class_ultra_cold_1_1_tools_1_1_input_parser.html">UltraCold::Tools::InputParser</a></div><div class="ttdoc">Class to read input parameters from files.</div><div class="ttdef"><b>Definition:</b> InputParser.hpp:93</div></div>
<div class="ttc" id="anamespace_ultra_cold_html"><div class="ttname"><a href="namespace_ultra_cold.html">UltraCold</a></div><div class="ttdoc">All the classes and functions necessary to work with UltraCold.</div><div class="ttdef"><b>Definition:</b> BogolyubovSolver.cpp:25</div></div>
</div><!-- fragment --><p >Then, we define the mesh, the initial wave-function and the external potential. Notice that we add some random noise to the initial wave-function. This usually results in a speed-up of the convergence of the gradient-descent iterations</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> dx = 2 * xmax / nx;</div>
<div class="line"><span class="keywordtype">double</span> dy = 2 * ymax / ny;</div>
<div class="line"><span class="keywordtype">double</span> dz = 2 * zmax / nz;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> x(nx), y(ny), z(nz), kx(nx), ky(ny), kz(nz);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nx; ++i) x[i] = -xmax + i * dx;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ny; ++i) y[i] = -ymax + i * dy;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nz; ++i) z[i] = -zmax + i * dz;</div>
<div class="line">create_mesh_in_Fourier_space(x, y, z, kx, ky, kz);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;std::complex&lt;double&gt;</a>&gt; psi(nx, ny, nz);</div>
<div class="line"><a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> Vext(nx, ny, nz);</div>
<div class="line"> </div>
<div class="line">std::default_random_engine generator;</div>
<div class="line">std::uniform_real_distribution&lt;double&gt; distribution(0,1);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nx; ++i)</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; ny; ++j)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; nz; ++k)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordtype">double</span> random_number = distribution(generator);</div>
<div class="line">            psi(i,j,k)  = (1.0+0.1*random_number)*</div>
<div class="line">                    std::exp(-0.1*(pow(x(i),2) +</div>
<div class="line">                                   pow(y(j),2) +</div>
<div class="line">                                   pow(z(k),2)) );</div>
<div class="line"> </div>
<div class="line">            Vext(i,j,k) = 0.5*( std::pow(omegax,2)*pow(x(i),2) +</div>
<div class="line">                                std::pow(omegay,2)*pow(y(j),2) +</div>
<div class="line">                                std::pow(omegaz,2)*pow(z(k),2) );</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> norm = 0.0;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) norm += std::norm(psi[i]);</div>
<div class="line">norm *= (dx * dy * dz);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) psi[i] *= std::sqrt(number_of_particles / norm);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="class_ultra_cold_1_1_real_space_output_1_1_data_out.html">UltraCold::RealSpaceOutput::DataOut</a> psi_out;</div>
<div class="line">psi_out.<a class="code hl_function" href="class_ultra_cold_1_1_real_space_output_1_1_data_out.html#acb4c018af1f731035d492cdccdb49b45">set_output_name</a>(<span class="stringliteral">&quot;initial_wave_function&quot;</span>);</div>
<div class="line">psi_out.<a class="code hl_function" href="class_ultra_cold_1_1_real_space_output_1_1_data_out.html#a8580f804548eaee31fb7e4d7388d30fd">write_slice2d_vtk</a>(x,y,psi,<span class="stringliteral">&quot;xy&quot;</span>,<span class="stringliteral">&quot;initial_wave_function&quot;</span>);</div>
<div class="ttc" id="aclass_ultra_cold_1_1_real_space_output_1_1_data_out_html"><div class="ttname"><a href="class_ultra_cold_1_1_real_space_output_1_1_data_out.html">UltraCold::RealSpaceOutput::DataOut</a></div><div class="ttdoc">A class to output a data Vector in real space.</div><div class="ttdef"><b>Definition:</b> DataOut.hpp:70</div></div>
<div class="ttc" id="aclass_ultra_cold_1_1_real_space_output_1_1_data_out_html_a8580f804548eaee31fb7e4d7388d30fd"><div class="ttname"><a href="class_ultra_cold_1_1_real_space_output_1_1_data_out.html#a8580f804548eaee31fb7e4d7388d30fd">UltraCold::RealSpaceOutput::DataOut::write_slice2d_vtk</a></div><div class="ttdeci">void write_slice2d_vtk(Vector&lt; double &gt; &amp;x_axis, Vector&lt; double &gt; &amp;y_axis, Vector&lt; double &gt; &amp;real_output_vector, const char *vector_name, const char *plane)</div><div class="ttdoc">Write an output data file in .vtk format, for 2D slice of real 3D Vector.</div><div class="ttdef"><b>Definition:</b> DataOut.cpp:1993</div></div>
<div class="ttc" id="aclass_ultra_cold_1_1_real_space_output_1_1_data_out_html_acb4c018af1f731035d492cdccdb49b45"><div class="ttname"><a href="class_ultra_cold_1_1_real_space_output_1_1_data_out.html#acb4c018af1f731035d492cdccdb49b45">UltraCold::RealSpaceOutput::DataOut::set_output_name</a></div><div class="ttdeci">void set_output_name(const std::string &amp;output_file_name)</div><div class="ttdoc">Set the name for the output data file, input as an std::string.</div><div class="ttdef"><b>Definition:</b> DataOut.cpp:30</div></div>
<div class="ttc" id="aclass_ultra_cold_1_1_vector_html"><div class="ttname"><a href="class_ultra_cold_1_1_vector.html">UltraCold::Vector&lt; double &gt;</a></div></div>
</div><!-- fragment --><p >Next, we define our solver class, and run the solver for finding the ground state of our dipolar Bose gas</p>
<div class="fragment"><div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_g_p_solvers_1_1_dipolar_g_p_solver.html">GPSolvers::DipolarGPSolver</a> dipolar_gp_solver(x,</div>
<div class="line">                                                 y,</div>
<div class="line">                                                 z,</div>
<div class="line">                                                 psi,</div>
<div class="line">                                                 Vext,</div>
<div class="line">                                                 scattering_length,</div>
<div class="line">                                                 dipolar_length);</div>
<div class="line">    <span class="keywordtype">double</span> chemical_potential;</div>
<div class="line">    std::tie(psi, chemical_potential) = dipolar_gp_solver.run_gradient_descent(number_of_gradient_descent_steps,</div>
<div class="line">                                                                               residual,</div>
<div class="line">                                                                               alpha,</div>
<div class="line">                                                                               beta,</div>
<div class="line">                                                                               std::cout);</div>
<div class="line"> </div>
<div class="line">    psi_out.<a class="code hl_function" href="class_ultra_cold_1_1_real_space_output_1_1_data_out.html#acb4c018af1f731035d492cdccdb49b45">set_output_name</a>(<span class="stringliteral">&quot;ground_state_wave_function&quot;</span>);</div>
<div class="line">    psi_out.<a class="code hl_function" href="class_ultra_cold_1_1_real_space_output_1_1_data_out.html#af8e7d71fa2f88a7405bbd24843125747">write_vtk</a>(x,y,z,psi,<span class="stringliteral">&quot;ground_state_wave_function&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="aclass_ultra_cold_1_1_g_p_solvers_1_1_dipolar_g_p_solver_html"><div class="ttname"><a href="class_ultra_cold_1_1_g_p_solvers_1_1_dipolar_g_p_solver.html">UltraCold::GPSolvers::DipolarGPSolver</a></div><div class="ttdoc">Class to solve the Gross-Pitaevskii equation for a dipolar Bose gas in two or three space dimensions.</div><div class="ttdef"><b>Definition:</b> GPSolvers.hpp:458</div></div>
<div class="ttc" id="aclass_ultra_cold_1_1_real_space_output_1_1_data_out_html_af8e7d71fa2f88a7405bbd24843125747"><div class="ttname"><a href="class_ultra_cold_1_1_real_space_output_1_1_data_out.html#af8e7d71fa2f88a7405bbd24843125747">UltraCold::RealSpaceOutput::DataOut::write_vtk</a></div><div class="ttdeci">void write_vtk(Vector&lt; double &gt; &amp;x_axis, Vector&lt; double &gt; &amp;y_axis, Vector&lt; double &gt; &amp;real_output_vector, const char *vector_name)</div><div class="ttdoc">Write an output data file in .vtk format, for real 2D output.</div><div class="ttdef"><b>Definition:</b> DataOut.cpp:1498</div></div>
</div><!-- fragment --><p >Let's get a look at the results.</p>
<h2><a class="anchor" id="Results-3"></a>
Results</h2>
<p >The ground state density profile can be visualized as usual by opening the output file <code>ground_state_wave_function.vtk</code>, where we saved the mesh as well as the real and the imaginary part of the calculated ground-state wave function. Using, as usual, <a href="https://www.paraview.org/">Paraview </a>, one can visualize slices of the ground-state density profiles along the three axis</p>
<div class="image">
<img src="example-3-density-cut-1.png" alt=""/>
</div>
 <div class="image">
<img src="example-3-density-cut-2.png" alt=""/>
</div>
 <div class="image">
<img src="example-3-density-cut-3.png" alt=""/>
</div>
<p >  </p>
<p >Notice that the ground state density profile is characterized by the appearance of equally-spaced density peaks "immersed" in a more dilute superfluid background. Such states, characterized by a periodic density modulation of a phase-coherent system, are called <b>supersolids</b> and have been observed in experiments carried out, respectively, in <a href="https://journals.aps.org/prl/pdf/10.1103/PhysRevLett.122.130405">Pisa </a>, <a href="https://journals.aps.org/prx/abstract/10.1103/PhysRevX.9.021012">Innsbruck </a>, and <a href="https://journals.aps.org/prx/abstract/10.1103/PhysRevX.9.011051">Stuttgart </a>. For a recent review on the field, see e.g. <a href="https://iopscience.iop.org/article/10.1088/1361-6633/abc9ab/meta">here </a>.</p>
<h2><a class="anchor" id="Possibilities-3"></a>
Possible extensions</h2>
<p >This program can be extended just like example-1 for the study of the dynamics of the system, considering for example the transition from an ordinary superfluid to a supersolid by a ramp in the scattering length.</p>
<h2><a class="anchor" id="Uncommented-3"></a>
The plain program</h2>
<div class="fragment"><div class="line"><span class="comment">/*--------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *    This file is part of the UltraCold project.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *    UltraCold is free software: you can redistribute it and/or modify</span></div>
<div class="line"><span class="comment"> *    it under the terms of the GNU General Public License as published by</span></div>
<div class="line"><span class="comment"> *    the Free Software Foundation, either version 3 of the License, or</span></div>
<div class="line"><span class="comment"> *    any later version.</span></div>
<div class="line"><span class="comment"> *    UltraCold is distributed in the hope that it will be useful,</span></div>
<div class="line"><span class="comment"> *    but WITHOUT ANY WARRANTY; without even the implied warranty of</span></div>
<div class="line"><span class="comment"> *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></div>
<div class="line"><span class="comment"> *    GNU General Public License for more details.</span></div>
<div class="line"><span class="comment"> *    You should have received a copy of the GNU General Public License</span></div>
<div class="line"><span class="comment"> *    along with UltraCold.  If not, see &lt;https://www.gnu.org/licenses/&gt;.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *--------------------------------------------------------------------------------*/</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;UltraCold.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;random&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespace_ultra_cold.html">UltraCold</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_tools_1_1_input_parser.html">Tools::InputParser</a> ip(<span class="stringliteral">&quot;example-3.prm&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    ip.read_input_file();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> xmax = ip.retrieve_double(<span class="stringliteral">&quot;xmax&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> ymax = ip.retrieve_double(<span class="stringliteral">&quot;ymax&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> zmax = ip.retrieve_double(<span class="stringliteral">&quot;zmax&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> nx = ip.retrieve_int(<span class="stringliteral">&quot;nx&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> ny = ip.retrieve_int(<span class="stringliteral">&quot;ny&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> nz = ip.retrieve_int(<span class="stringliteral">&quot;nz&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> scattering_length         = ip.retrieve_double(<span class="stringliteral">&quot;scattering length&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> dipolar_length            = ip.retrieve_double(<span class="stringliteral">&quot;dipolar_length&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>    number_of_particles = ip.retrieve_int(<span class="stringliteral">&quot;number of particles&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> atomic_mass         = ip.retrieve_double(<span class="stringliteral">&quot;atomic mass&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> omegax                    = ip.retrieve_double(<span class="stringliteral">&quot;omegax&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> omegay                    = ip.retrieve_double(<span class="stringliteral">&quot;omegay&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> omegaz                    = ip.retrieve_double(<span class="stringliteral">&quot;omegaz&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>    number_of_gradient_descent_steps = ip.retrieve_int(<span class="stringliteral">&quot;number of gradient descent steps&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> residual                         = ip.retrieve_double(<span class="stringliteral">&quot;residual&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> alpha                            = ip.retrieve_double(<span class="stringliteral">&quot;alpha&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> beta                             = ip.retrieve_double(<span class="stringliteral">&quot;beta&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> hbar        = 0.6347*1.E5;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> bohr_radius = 5.292E-5;</div>
<div class="line"> </div>
<div class="line">    omegax *= TWOPI;</div>
<div class="line">    omegay *= TWOPI;</div>
<div class="line">    omegaz *= TWOPI;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> omega_ho = std::cbrt(omegax*omegay*omegaz);</div>
<div class="line"> </div>
<div class="line">    omegax = omegax/omega_ho;</div>
<div class="line">    omegay = omegay/omega_ho;</div>
<div class="line">    omegaz = omegaz/omega_ho;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> a_ho = std::sqrt(hbar/(atomic_mass*omega_ho));</div>
<div class="line"> </div>
<div class="line">    scattering_length *= bohr_radius/a_ho;</div>
<div class="line">    dipolar_length *= bohr_radius/a_ho;</div>
<div class="line"> </div>
<div class="line">    xmax = xmax/a_ho;</div>
<div class="line">    ymax = ymax/a_ho;</div>
<div class="line">    zmax = zmax/a_ho;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> dx = 2 * xmax / nx;</div>
<div class="line">    <span class="keywordtype">double</span> dy = 2 * ymax / ny;</div>
<div class="line">    <span class="keywordtype">double</span> dz = 2 * zmax / nz;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> x(nx), y(ny), z(nz), kx(nx), ky(ny), kz(nz);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nx; ++i) x[i] = -xmax + i * dx;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ny; ++i) y[i] = -ymax + i * dy;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nz; ++i) z[i] = -zmax + i * dz;</div>
<div class="line">    create_mesh_in_Fourier_space(x, y, z, kx, ky, kz);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;std::complex&lt;double&gt;</a>&gt; psi(nx, ny, nz);</div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> Vext(nx, ny, nz);</div>
<div class="line"> </div>
<div class="line">    std::default_random_engine generator;</div>
<div class="line">    std::uniform_real_distribution&lt;double&gt; distribution(0,1);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nx; ++i)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; ny; ++j)</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; nz; ++k)</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordtype">double</span> random_number = distribution(generator);</div>
<div class="line">                psi(i,j,k)  = (1.0+0.1*random_number)*</div>
<div class="line">                        std::exp(-0.1*(pow(x(i),2) +</div>
<div class="line">                                       pow(y(j),2) +</div>
<div class="line">                                       pow(z(k),2)) );</div>
<div class="line"> </div>
<div class="line">                Vext(i,j,k) = 0.5*( std::pow(omegax,2)*pow(x(i),2) +</div>
<div class="line">                                    std::pow(omegay,2)*pow(y(j),2) +</div>
<div class="line">                                    std::pow(omegaz,2)*pow(z(k),2) );</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> norm = 0.0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) norm += std::norm(psi[i]);</div>
<div class="line">    norm *= (dx * dy * dz);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) psi[i] *= std::sqrt(number_of_particles / norm);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_real_space_output_1_1_data_out.html">UltraCold::RealSpaceOutput::DataOut</a> psi_out;</div>
<div class="line">    psi_out.<a class="code hl_function" href="class_ultra_cold_1_1_real_space_output_1_1_data_out.html#acb4c018af1f731035d492cdccdb49b45">set_output_name</a>(<span class="stringliteral">&quot;initial_wave_function&quot;</span>);</div>
<div class="line">    psi_out.<a class="code hl_function" href="class_ultra_cold_1_1_real_space_output_1_1_data_out.html#a8580f804548eaee31fb7e4d7388d30fd">write_slice2d_vtk</a>(x,y,psi,<span class="stringliteral">&quot;xy&quot;</span>,<span class="stringliteral">&quot;initial_wave_function&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_g_p_solvers_1_1_dipolar_g_p_solver.html">GPSolvers::DipolarGPSolver</a> dipolar_gp_solver(x,</div>
<div class="line">                                                  y,</div>
<div class="line">                                                  z,</div>
<div class="line">                                                  psi,</div>
<div class="line">                                                  Vext,</div>
<div class="line">                                                  scattering_length,</div>
<div class="line">                                                  dipolar_length);</div>
<div class="line">    <span class="keywordtype">double</span> chemical_potential;</div>
<div class="line">    std::tie(psi, chemical_potential) = dipolar_gp_solver.run_gradient_descent(number_of_gradient_descent_steps,</div>
<div class="line">                                                                               residual,</div>
<div class="line">                                                                               alpha,</div>
<div class="line">                                                                               beta,</div>
<div class="line">                                                                               std::cout);</div>
<div class="line"> </div>
<div class="line">    psi_out.<a class="code hl_function" href="class_ultra_cold_1_1_real_space_output_1_1_data_out.html#acb4c018af1f731035d492cdccdb49b45">set_output_name</a>(<span class="stringliteral">&quot;ground_state_wave_function&quot;</span>);</div>
<div class="line">    psi_out.<a class="code hl_function" href="class_ultra_cold_1_1_real_space_output_1_1_data_out.html#af8e7d71fa2f88a7405bbd24843125747">write_vtk</a>(x,y,z,psi,<span class="stringliteral">&quot;ground_state_wave_function&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section author"><dt>Author</dt><dd>Santo Maria Roccuzzo (<a href="#" onclick="location.href='mai'+'lto:'+'san'+'to'+'m.r'+'oc'+'cuz'+'zo'+'@gm'+'ai'+'l.c'+'om'; return false;">santo<span class="obfuscator">.nosp@m.</span>m.ro<span class="obfuscator">.nosp@m.</span>ccuzz<span class="obfuscator">.nosp@m.</span>o@gm<span class="obfuscator">.nosp@m.</span>ail.c<span class="obfuscator">.nosp@m.</span>om</a>)</dd></dl>
<h1><a class="anchor" id="Title-3"></a>
A three-dimensional dipolar Bose gas in a harmonic trap.</h1>
<h2><a class="anchor" id="Introduction-3"></a>
Introduction</h2>
<p >In this example, we are going to use UltraCold to study the ground state and of a three-dimensional, harmonically trapped <b>dipolar</b> Bose gas of \( ^{164}Dy \) atoms, using the solver class <code><a class="el" href="class_ultra_cold_1_1_g_p_solvers_1_1_dipolar_g_p_solver.html" title="Class to solve the Gross-Pitaevskii equation for a dipolar Bose gas in two or three space dimensions.">UltraCold::GPSolvers::DipolarGPSolver</a></code>.</p>
<p >Bose-Einstein condensates have been obtained in atomic species, like <a href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.108.210401">Erbium </a> or <a href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.107.190401">Dysprosium </a>, possessing a strong magnetic dipole moment in their ground state. This implies that, in order to describe the physics of such BECs, it is necessary to take into account the effect of magnetic interactions between the atoms. In the typical setup, atoms are aligned along a certain direction (say, the x-axis) by an external magnetic field, and their dipole-dipole interaction potential has the form</p>
<p class="formulaDsp">
\[
    V_{dd}({\bf r}-{\bf r}&#39;) = \frac{\mu_0\mu^2}{4\pi}\frac{1-3\cos^2(\theta)}{|{\bf r}-{\bf r}&#39;|^3}
\]
</p>
<p >with \( \mu_0 \) the magnetic permeability in vacuum, \( \mu \) the magnetic dipole moment and \( \theta \) the angle between the vector distance between dipoles and the polarization direction, i.e. in this case the \( x \)-axis. A simple mean-field description has been shown to fail in describing the observed properties of dipolar BECs. Currently, the most commonly used model for the description of dipolar BECs takes into account the first-order beyond mean-field correction to the ground-state energy of the system in the local density approximation. Such <a href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.86.063609">Lee-Huang-Yang </a> (LHY) correction for a uniform system is given by</p>
<p class="formulaDsp">
\[
 \frac{E_0}{V}=\frac{1}{2}gn^2\left[1+\frac{128}{15\sqrt{\pi}}\sqrt{na^3}F(\epsilon_{dd})\right]
\]
</p>
<p> with </p><p class="formulaDsp">
\[
 F(\epsilon_{dd})=\frac{1}{2}\int_0^{\pi}d\theta sin\theta[1+\epsilon_{dd}(3cos^2\theta-1)]^{\frac{5}{2}}
\]
</p>
<p >Inserting this correction in the local density approximation in a mean-field model, we obtain the extended Gross-Pitaevskii equation</p>
<p class="formulaDsp">
\[
\begin{align}
 &amp;i\hbar\frac{\partial}{\partial t}  \Psi({\bf r},t)= \mathcal{H}({\bf r})\,\Psi({\bf r},t)\,,
\end{align}
\]
</p>
<p >where the Hamiltonian \( H \) is</p>
<p class="formulaDsp">
\[
 \begin{align}
  \mathcal{H}({\bf r})=-&amp;\frac{\hbar^2}{2m}\nabla^2+V_{\rm ext}({\bf r})+g|\Psi({\bf r},t)|^2+\gamma
  (\varepsilon_{dd})|\Psi({\bf r},t)|^3\nonumber\\
  +&amp; \int d{\bf r&#39;}V_{dd}({\bf r}-{\bf r&#39;})|\Psi({\bf r&#39;},t)|^2\,,
 \end{align}
\]
</p>
<p >with \( g=4\pi\hbar^2a/m \) the coupling constant fixed by the \( s \)-wave scattering length \( a \) and</p>
<p class="formulaDsp">
\[
 \gamma(\varepsilon_{dd})=\frac{16}{3\sqrt{\pi}} ga^{\frac{3}{2}}\,\mbox{Re}\bigg[\!\int_0^{\pi}
 \!\!\!\!d\theta\sin\theta [1+\varepsilon_{dd}(3\cos^2\theta-1)]^{\frac{5}{2}}\bigg]\,.
\]
</p>
<p >In the absence of trapping, the system can be fully characterised by the single parameter \( \varepsilon_{dd}=\mu_0\mu^2/(3g)=a_{dd}/a \), i.e., the ratio between the strength of the dipolar and the contact interaction, eventually written in terms of the dipolar length \( a_{dd} \) and the scattering length \( a \).</p>
<p >Among the peculiar effects described by this model, we mention the possibility of describing the so-called <a href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.93.061603">quantum droplets </a>, i.e. ultra-dilute, self-bound, liquid-like droplets in the Bose-Einstein condensed phase, and <a href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.99.041601">supersolids </a>, i.e. phase-coherent systems spontaneously breaking translational invariance, developing spatial periodicity.</p>
<p >In this example, we will use the solver class <code><a class="el" href="class_ultra_cold_1_1_g_p_solvers_1_1_dipolar_g_p_solver.html" title="Class to solve the Gross-Pitaevskii equation for a dipolar Bose gas in two or three space dimensions.">UltraCold::GPSolvers::DipolarGPSolver</a></code> to describe a simple supersolid state of a dipolar gas in a cigar-shaped harmonic trap.</p>
<h2><a class="anchor" id="What-3"></a>
Program description</h2>
<p >We first create an input file containing our mesh and physical parameters, as well as other parameters determining the run-time behavior of the system. Such input file will be called <code>example-3.prm</code> and contains the following text</p>
<pre class="fragment"># Mesh parameters

xmax = 10.0 # Size of the mesh along the x-axis, in micrometers. The mesh will extend from -xmax to xmax
ymax = 10.0 # Size of the mesh along the y-axis, in micrometers. The mesh will extend from -ymax to ymax
zmax = 15.0 # Size of the mesh along the z-axis, in micrometers. The mesh will extend from -zmax to zmax

nx = 64 # Number of points along the x-axis
ny = 64 # Number of points along the y-axis
nz = 128 # Number of points along the z-axis

# Physical parameters

scattering length   = 95.0 # Scattering length in units of the Bohr radius
dipolar_length      = 132.0 # Dipolar length in units of the Bohr radius
number of particles = 40000  # Total number of atoms
atomic mass         = 164    # Atomic mass, in atomic mass units
omegax = 90 # Harmonic frequency along the x-axis, in units of (2pi)Hz
omegay = 60 # Harmonic frequency along the y-axis, in units of (2pi)Hz
omegaz = 30 # Harmonic frequency along the z-axis, in units of (2pi)Hz

# Run parameters for gradient descent

number of gradient descent steps = 20000 # maximum number of gradient descent steps
residual                         = 1.E-6 # Threshold on the norm of the residual
alpha                            = 1.E-3 # gradient descent step
beta                             = 0.9   # step for the heavy-ball acceleration method</pre><p >Notice that the mesh is anisotropic, as well as the harmonic trap. In particular, we are using a trap elongated along the z-axis, and tighter along the x-axis. This is because the dipoles are aligned along the x-direction, and so, due to the partially attractive nature of the dipolar potential, they will try to "pile-up" in order to reach the lower energy attractive configuration with the dipoles sitting "head-to-tail". This can be partially prevented by using a tight harmonic trap along the polarization direction. Nonetheless, in the pure mean-field picture, using these parameters, the model would not admit any stable ground-state. Practically, solving the model without the LHY correction for the lowest energy state would result in a collapsed state, with the full wave-function concentrated in a single point of the mesh. Instead, the LHY correction will produce an interesting and stable ground-state configuration.</p>
<p >Let's look at the program. As in previous examples, we first read our input parameter file and set harmonic units</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;UltraCold.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;random&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespace_ultra_cold.html">UltraCold</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_tools_1_1_input_parser.html">Tools::InputParser</a> ip(<span class="stringliteral">&quot;example-3.prm&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    ip.read_input_file();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> xmax = ip.retrieve_double(<span class="stringliteral">&quot;xmax&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> ymax = ip.retrieve_double(<span class="stringliteral">&quot;ymax&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> zmax = ip.retrieve_double(<span class="stringliteral">&quot;zmax&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> nx = ip.retrieve_int(<span class="stringliteral">&quot;nx&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> ny = ip.retrieve_int(<span class="stringliteral">&quot;ny&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> nz = ip.retrieve_int(<span class="stringliteral">&quot;nz&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> scattering_length         = ip.retrieve_double(<span class="stringliteral">&quot;scattering length&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> dipolar_length            = ip.retrieve_double(<span class="stringliteral">&quot;dipolar_length&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>    number_of_particles = ip.retrieve_int(<span class="stringliteral">&quot;number of particles&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> atomic_mass         = ip.retrieve_double(<span class="stringliteral">&quot;atomic mass&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> omegax                    = ip.retrieve_double(<span class="stringliteral">&quot;omegax&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> omegay                    = ip.retrieve_double(<span class="stringliteral">&quot;omegay&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> omegaz                    = ip.retrieve_double(<span class="stringliteral">&quot;omegaz&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>    number_of_gradient_descent_steps = ip.retrieve_int(<span class="stringliteral">&quot;number of gradient descent steps&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> residual                         = ip.retrieve_double(<span class="stringliteral">&quot;residual&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> alpha                            = ip.retrieve_double(<span class="stringliteral">&quot;alpha&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> beta                             = ip.retrieve_double(<span class="stringliteral">&quot;beta&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> hbar        = 0.6347*1.E5;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> bohr_radius = 5.292E-5;</div>
<div class="line"> </div>
<div class="line">    omegax *= TWOPI;</div>
<div class="line">    omegay *= TWOPI;</div>
<div class="line">    omegaz *= TWOPI;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> omega_ho = std::cbrt(omegax*omegay*omegaz);</div>
<div class="line"> </div>
<div class="line">    omegax = omegax/omega_ho;</div>
<div class="line">    omegay = omegay/omega_ho;</div>
<div class="line">    omegaz = omegaz/omega_ho;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> a_ho = std::sqrt(hbar/(atomic_mass*omega_ho));</div>
<div class="line"> </div>
<div class="line">    scattering_length *= bohr_radius/a_ho;</div>
<div class="line">    dipolar_length *= bohr_radius/a_ho;</div>
<div class="line"> </div>
<div class="line">    xmax = xmax/a_ho;</div>
<div class="line">    ymax = ymax/a_ho;</div>
<div class="line">    zmax = zmax/a_ho;</div>
</div><!-- fragment --><p >Then, we define the mesh, the initial wave-function and the external potential. Notice that we add some random noise to the initial wave-function. This usually results in a speed-up of the convergence of the gradient-descent iterations</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> dx = 2 * xmax / nx;</div>
<div class="line"><span class="keywordtype">double</span> dy = 2 * ymax / ny;</div>
<div class="line"><span class="keywordtype">double</span> dz = 2 * zmax / nz;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> x(nx), y(ny), z(nz), kx(nx), ky(ny), kz(nz);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nx; ++i) x[i] = -xmax + i * dx;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ny; ++i) y[i] = -ymax + i * dy;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nz; ++i) z[i] = -zmax + i * dz;</div>
<div class="line">create_mesh_in_Fourier_space(x, y, z, kx, ky, kz);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;std::complex&lt;double&gt;</a>&gt; psi(nx, ny, nz);</div>
<div class="line"><a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> Vext(nx, ny, nz);</div>
<div class="line"> </div>
<div class="line">std::default_random_engine generator;</div>
<div class="line">std::uniform_real_distribution&lt;double&gt; distribution(0,1);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nx; ++i)</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; ny; ++j)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; nz; ++k)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordtype">double</span> random_number = distribution(generator);</div>
<div class="line">            psi(i,j,k)  = (1.0+0.1*random_number)*</div>
<div class="line">                    std::exp(-0.1*(pow(x(i),2) +</div>
<div class="line">                                   pow(y(j),2) +</div>
<div class="line">                                   pow(z(k),2)) );</div>
<div class="line"> </div>
<div class="line">            Vext(i,j,k) = 0.5*( std::pow(omegax,2)*pow(x(i),2) +</div>
<div class="line">                                std::pow(omegay,2)*pow(y(j),2) +</div>
<div class="line">                                std::pow(omegaz,2)*pow(z(k),2) );</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> norm = 0.0;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) norm += std::norm(psi[i]);</div>
<div class="line">norm *= (dx * dy * dz);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) psi[i] *= std::sqrt(number_of_particles / norm);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="class_ultra_cold_1_1_real_space_output_1_1_data_out.html">UltraCold::RealSpaceOutput::DataOut</a> psi_out;</div>
<div class="line">psi_out.<a class="code hl_function" href="class_ultra_cold_1_1_real_space_output_1_1_data_out.html#acb4c018af1f731035d492cdccdb49b45">set_output_name</a>(<span class="stringliteral">&quot;initial_wave_function&quot;</span>);</div>
<div class="line">psi_out.<a class="code hl_function" href="class_ultra_cold_1_1_real_space_output_1_1_data_out.html#a8580f804548eaee31fb7e4d7388d30fd">write_slice2d_vtk</a>(x,y,psi,<span class="stringliteral">&quot;xy&quot;</span>,<span class="stringliteral">&quot;initial_wave_function&quot;</span>);</div>
</div><!-- fragment --><p >Next, we define our solver class, and run the solver for finding the ground state of our dipolar Bose gas</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_ultra_cold_1_1_g_p_solvers_1_1_dipolar_g_p_solver.html">GPSolvers::DipolarGPSolver</a> dipolar_gp_solver(x,</div>
<div class="line">                                              y,</div>
<div class="line">                                              z,</div>
<div class="line">                                              psi,</div>
<div class="line">                                              Vext,</div>
<div class="line">                                              scattering_length,</div>
<div class="line">                                              dipolar_length);</div>
<div class="line"><span class="keywordtype">double</span> chemical_potential;</div>
<div class="line">std::tie(psi, chemical_potential) = dipolar_gp_solver.run_gradient_descent(number_of_gradient_descent_steps,</div>
<div class="line">                                                                           residual,</div>
<div class="line">                                                                           alpha,</div>
<div class="line">                                                                           beta,</div>
<div class="line">                                                                           std::cout);</div>
<div class="line"> </div>
<div class="line">psi_out.<a class="code hl_function" href="class_ultra_cold_1_1_real_space_output_1_1_data_out.html#acb4c018af1f731035d492cdccdb49b45">set_output_name</a>(<span class="stringliteral">&quot;ground_state_wave_function&quot;</span>);</div>
<div class="line">psi_out.<a class="code hl_function" href="class_ultra_cold_1_1_real_space_output_1_1_data_out.html#af8e7d71fa2f88a7405bbd24843125747">write_vtk</a>(x,y,z,psi,<span class="stringliteral">&quot;ground_state_wave_function&quot;</span>);</div>
</div><!-- fragment --><p >Let's get a look at the results.</p>
<h2><a class="anchor" id="Results-3"></a>
Results</h2>
<p >The ground state density profile can be visualized as usual by opening the output file <code>ground_state_wave_function.vtk</code>, where we saved the mesh as well as the real and the imaginary part of the calculated ground-state wave function. Using, as usual, <a href="https://www.paraview.org/">Paraview </a>, one can visualize slices of the ground-state density profiles along the three axis</p>
<div class="image">
<img src="example-3-density-cut-1.png" alt=""/>
</div>
 <div class="image">
<img src="example-3-density-cut-2.png" alt=""/>
</div>
 <div class="image">
<img src="example-3-density-cut-3.png" alt=""/>
</div>
<p >  </p>
<p >Notice that the ground state density profile is characterized by the appearance of equally-spaced density peaks "immersed" in a more dilute superfluid background. Such states, characterized by a periodic density modulation of a phase-coherent system, are called <b>supersolids</b> and have been observed in experiments carried out, respectively, in <a href="https://journals.aps.org/prl/pdf/10.1103/PhysRevLett.122.130405">Pisa </a>, <a href="https://journals.aps.org/prx/abstract/10.1103/PhysRevX.9.021012">Innsbruck </a>, and <a href="https://journals.aps.org/prx/abstract/10.1103/PhysRevX.9.011051">Stuttgart </a>. For a recent review on the field, see e.g. <a href="https://iopscience.iop.org/article/10.1088/1361-6633/abc9ab/meta">here </a>.</p>
<h2><a class="anchor" id="Possibilities-3"></a>
Possible extensions</h2>
<p >This program can be extended just like example-1 for the study of the dynamics of the system, considering for example the transition from an ordinary superfluid to a supersolid by a ramp in the scattering length.</p>
<h2><a class="anchor" id="Uncommented-3"></a>
The plain program</h2>
<div class="fragment"><div class="line"><span class="comment">/*--------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *    This file is part of the UltraCold project.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *    UltraCold is free software: you can redistribute it and/or modify</span></div>
<div class="line"><span class="comment"> *    it under the terms of the GNU General Public License as published by</span></div>
<div class="line"><span class="comment"> *    the Free Software Foundation, either version 3 of the License, or</span></div>
<div class="line"><span class="comment"> *    any later version.</span></div>
<div class="line"><span class="comment"> *    UltraCold is distributed in the hope that it will be useful,</span></div>
<div class="line"><span class="comment"> *    but WITHOUT ANY WARRANTY; without even the implied warranty of</span></div>
<div class="line"><span class="comment"> *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></div>
<div class="line"><span class="comment"> *    GNU General Public License for more details.</span></div>
<div class="line"><span class="comment"> *    You should have received a copy of the GNU General Public License</span></div>
<div class="line"><span class="comment"> *    along with UltraCold.  If not, see &lt;https://www.gnu.org/licenses/&gt;.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *--------------------------------------------------------------------------------*/</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;UltraCold.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;random&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespace_ultra_cold.html">UltraCold</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_tools_1_1_input_parser.html">Tools::InputParser</a> ip(<span class="stringliteral">&quot;example-3.prm&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    ip.read_input_file();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> xmax = ip.retrieve_double(<span class="stringliteral">&quot;xmax&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> ymax = ip.retrieve_double(<span class="stringliteral">&quot;ymax&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> zmax = ip.retrieve_double(<span class="stringliteral">&quot;zmax&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> nx = ip.retrieve_int(<span class="stringliteral">&quot;nx&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> ny = ip.retrieve_int(<span class="stringliteral">&quot;ny&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> nz = ip.retrieve_int(<span class="stringliteral">&quot;nz&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> scattering_length         = ip.retrieve_double(<span class="stringliteral">&quot;scattering length&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> dipolar_length            = ip.retrieve_double(<span class="stringliteral">&quot;dipolar_length&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>    number_of_particles = ip.retrieve_int(<span class="stringliteral">&quot;number of particles&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> atomic_mass         = ip.retrieve_double(<span class="stringliteral">&quot;atomic mass&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> omegax                    = ip.retrieve_double(<span class="stringliteral">&quot;omegax&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> omegay                    = ip.retrieve_double(<span class="stringliteral">&quot;omegay&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> omegaz                    = ip.retrieve_double(<span class="stringliteral">&quot;omegaz&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>    number_of_gradient_descent_steps = ip.retrieve_int(<span class="stringliteral">&quot;number of gradient descent steps&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> residual                         = ip.retrieve_double(<span class="stringliteral">&quot;residual&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> alpha                            = ip.retrieve_double(<span class="stringliteral">&quot;alpha&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> beta                             = ip.retrieve_double(<span class="stringliteral">&quot;beta&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> hbar        = 0.6347*1.E5;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> bohr_radius = 5.292E-5;</div>
<div class="line"> </div>
<div class="line">    omegax *= TWOPI;</div>
<div class="line">    omegay *= TWOPI;</div>
<div class="line">    omegaz *= TWOPI;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> omega_ho = std::cbrt(omegax*omegay*omegaz);</div>
<div class="line"> </div>
<div class="line">    omegax = omegax/omega_ho;</div>
<div class="line">    omegay = omegay/omega_ho;</div>
<div class="line">    omegaz = omegaz/omega_ho;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> a_ho = std::sqrt(hbar/(atomic_mass*omega_ho));</div>
<div class="line"> </div>
<div class="line">    scattering_length *= bohr_radius/a_ho;</div>
<div class="line">    dipolar_length *= bohr_radius/a_ho;</div>
<div class="line"> </div>
<div class="line">    xmax = xmax/a_ho;</div>
<div class="line">    ymax = ymax/a_ho;</div>
<div class="line">    zmax = zmax/a_ho;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> dx = 2 * xmax / nx;</div>
<div class="line">    <span class="keywordtype">double</span> dy = 2 * ymax / ny;</div>
<div class="line">    <span class="keywordtype">double</span> dz = 2 * zmax / nz;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> x(nx), y(ny), z(nz), kx(nx), ky(ny), kz(nz);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nx; ++i) x[i] = -xmax + i * dx;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ny; ++i) y[i] = -ymax + i * dy;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nz; ++i) z[i] = -zmax + i * dz;</div>
<div class="line">    create_mesh_in_Fourier_space(x, y, z, kx, ky, kz);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;std::complex&lt;double&gt;</a>&gt; psi(nx, ny, nz);</div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_vector.html">Vector&lt;double&gt;</a> Vext(nx, ny, nz);</div>
<div class="line"> </div>
<div class="line">    std::default_random_engine generator;</div>
<div class="line">    std::uniform_real_distribution&lt;double&gt; distribution(0,1);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nx; ++i)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; ny; ++j)</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; nz; ++k)</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordtype">double</span> random_number = distribution(generator);</div>
<div class="line">                psi(i,j,k)  = (1.0+0.1*random_number)*</div>
<div class="line">                        std::exp(-0.1*(pow(x(i),2) +</div>
<div class="line">                                       pow(y(j),2) +</div>
<div class="line">                                       pow(z(k),2)) );</div>
<div class="line"> </div>
<div class="line">                Vext(i,j,k) = 0.5*( std::pow(omegax,2)*pow(x(i),2) +</div>
<div class="line">                                    std::pow(omegay,2)*pow(y(j),2) +</div>
<div class="line">                                    std::pow(omegaz,2)*pow(z(k),2) );</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> norm = 0.0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) norm += std::norm(psi[i]);</div>
<div class="line">    norm *= (dx * dy * dz);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; psi.size(); ++i) psi[i] *= std::sqrt(number_of_particles / norm);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_real_space_output_1_1_data_out.html">UltraCold::RealSpaceOutput::DataOut</a> psi_out;</div>
<div class="line">    psi_out.<a class="code hl_function" href="class_ultra_cold_1_1_real_space_output_1_1_data_out.html#acb4c018af1f731035d492cdccdb49b45">set_output_name</a>(<span class="stringliteral">&quot;initial_wave_function&quot;</span>);</div>
<div class="line">    psi_out.<a class="code hl_function" href="class_ultra_cold_1_1_real_space_output_1_1_data_out.html#a8580f804548eaee31fb7e4d7388d30fd">write_slice2d_vtk</a>(x,y,psi,<span class="stringliteral">&quot;xy&quot;</span>,<span class="stringliteral">&quot;initial_wave_function&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_ultra_cold_1_1_g_p_solvers_1_1_dipolar_g_p_solver.html">GPSolvers::DipolarGPSolver</a> dipolar_gp_solver(x,</div>
<div class="line">                                                  y,</div>
<div class="line">                                                  z,</div>
<div class="line">                                                  psi,</div>
<div class="line">                                                  Vext,</div>
<div class="line">                                                  scattering_length,</div>
<div class="line">                                                  dipolar_length);</div>
<div class="line">    <span class="keywordtype">double</span> chemical_potential;</div>
<div class="line">    std::tie(psi, chemical_potential) = dipolar_gp_solver.run_gradient_descent(number_of_gradient_descent_steps,</div>
<div class="line">                                                                               residual,</div>
<div class="line">                                                                               alpha,</div>
<div class="line">                                                                               beta,</div>
<div class="line">                                                                               std::cout);</div>
<div class="line"> </div>
<div class="line">    psi_out.<a class="code hl_function" href="class_ultra_cold_1_1_real_space_output_1_1_data_out.html#acb4c018af1f731035d492cdccdb49b45">set_output_name</a>(<span class="stringliteral">&quot;ground_state_wave_function&quot;</span>);</div>
<div class="line">    psi_out.<a class="code hl_function" href="class_ultra_cold_1_1_real_space_output_1_1_data_out.html#af8e7d71fa2f88a7405bbd24843125747">write_vtk</a>(x,y,z,psi,<span class="stringliteral">&quot;ground_state_wave_function&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
